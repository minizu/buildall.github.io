<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>用代码说明JavaScript里的继承 | 把生命浪费在美好的代码上</title><link rel="stylesheet" href="/libs/normalize.min.css"><link rel="stylesheet" href="/libs/font-awesome-4.6.3/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="coderunthings.com/2015/11/06/inheritance/"/>
<meta name="description" content="JavaScript是通过prototype来实现继承的。也就是人们常说的”原型继承”。
本文的目的就是用代码来说明，到底什么是原型继承。
原型是什么JavaScript里有两个“原型”:1.prototype2.__proto__
prototype，是JavaScript里由关键字”function”定义的对象的一个特有的属性，这个属性本身又是一个对象。可能大多数不熟悉原型概念的人看到这句话会">
<meta property="og:type" content="article">
<meta property="og:title" content="用代码说明JavaScript里的继承">
<meta property="og:url" content="coderunthings.com/2015/11/06/inheritance/index.html">
<meta property="og:site_name" content="把生命浪费在美好的代码上">
<meta property="og:description" content="JavaScript是通过prototype来实现继承的。也就是人们常说的”原型继承”。
本文的目的就是用代码来说明，到底什么是原型继承。
原型是什么JavaScript里有两个“原型”:1.prototype2.__proto__
prototype，是JavaScript里由关键字”function”定义的对象的一个特有的属性，这个属性本身又是一个对象。可能大多数不熟悉原型概念的人看到这句话会">
<meta property="og:image" content="coderunthings.com/images/javascript_logo/js.jpg">
<meta property="og:updated_time" content="2017-08-23T19:18:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="用代码说明JavaScript里的继承">
<meta name="twitter:description" content="JavaScript是通过prototype来实现继承的。也就是人们常说的”原型继承”。
本文的目的就是用代码来说明，到底什么是原型继承。
原型是什么JavaScript里有两个“原型”:1.prototype2.__proto__
prototype，是JavaScript里由关键字”function”定义的对象的一个特有的属性，这个属性本身又是一个对象。可能大多数不熟悉原型概念的人看到这句话会"><meta property="article:author" content="Zhao Biao"><link rel="icon" href="/images/site-logo.png"><link rel="alternative" href="/atom.xml" type="application/atom+xml" title="把生命浪费在美好的代码上"></head><body itemscope itemtype="https://schema.org/WebPage"><nav id="menu" class="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a href="/" title="Home" rel="home" class="menu__item__link menu__item__link--brand"><img src="/images/site-logo.png" alt="把生命浪费在美好的代码上" class="menu__item__link--brand__image"><span class="menu__item__link--brand__label">把生命浪费在美好的代码上</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a href="/" class="menu__item__link">Home</a></div><div class="menu__item"><a href="/archives" class="menu__item__link">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-outer"><div itemscope itemtype="https://schema.org/Blog" class="content-inner"><article id="article" itemscope itemtype="https://schema.org/BlogPosting" class="article"><h1 itemprop="headline" class="article__title">用代码说明JavaScript里的继承</h1><div class="article__meta"><time datetime="2015-11-06T02:45:42.000Z" itemprop="datePublished" class="article__meta__time">2015-11-06 10:45:42</time><div class="article__meta__categories"><a href="/categories/JavaScript/" class="article__meta__categories__item">JavaScript</a></div></div><div class="article__contents"><img src="/images/javascript_logo/js.jpg"/><p>JavaScript是通过prototype来实现继承的。也就是人们常说的”原型继承”。</p>
<p>本文的目的就是用代码来说明，到底什么是原型继承。</p>
<h2 id="原型是什么"><a href="#原型是什么" class="headerlink" title="原型是什么"></a>原型是什么</h2><p>JavaScript里有两个“原型”:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>prototype</span><br><span class="line"><span class="number">2.</span>__proto__</span><br></pre></td></tr></table></figure></p>
<p>prototype，是JavaScript里由关键字”function”定义的对象的一个特有的属性，这个属性本身又是一个对象。可能大多数不熟悉原型概念的人看到这句话会有点晕，OK，让我们打开控制台，敲几行代码感受下吧。打开你的chrome浏览器，按F12或者command+option+i，并选中控制台(console)，输入以下代码(注：控制台中可以按ctrl+enter来换行):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> IamFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//定义一个函数</span></span><br><span class="line"><span class="built_in">console</span>.log(IamFunction.prototype);<span class="comment">//打印结果为IamFunction &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> IamObject = &#123;&#125;;<span class="comment">//定义一个对象</span></span><br><span class="line"><span class="built_in">console</span>.log(IamObject.prototype);<span class="comment">//打印结果为undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> IamNumber = <span class="number">0</span>;<span class="comment">//定义一个数字</span></span><br><span class="line"><span class="built_in">console</span>.log(IamNumber.prototype);<span class="comment">//打印结果为undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> IamString = <span class="string">''</span>;<span class="comment">//定义一个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(IamString.prototype);<span class="comment">//打印结果为undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> IamArray = [];<span class="comment">//定义一个数组</span></span><br><span class="line"><span class="built_in">console</span>.log(IamArray.prototype);<span class="comment">//打印结果为undefined</span></span><br></pre></td></tr></table></figure>
<p>由上面的代码可以看出，所谓prototype这个东西，只存在于某个function。(这里并没有检查JavaScript中所有的数据类型上prototype属性，但结果是一样的，你可以自己试一下，只有function类型会有prototype属性。)在上面的例子中，打印结果”IamFunction {}”就表示，prototype就是IamFunction的一个属性，它的默认值是{}。</p>
<p>除了Function构造的对象上prototype属性，JavaScript里还有一个地方有“原型”，既由构造函数创建的对象的__proto__属性。关于这个__proto__属性，请看下面的内容吧。</p>
<h2 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h2><p>JS里的函数有两种调用方法:普通调用和作为构造函数调用。既：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>)</span>&#123;&#125;      <span class="comment">//定义一个函数Func</span></span><br><span class="line">Func();                <span class="comment">//普通调用， 没有关键字new</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Func();  <span class="comment">//当作构造函数调用，有关键字new</span></span><br></pre></td></tr></table></figure>
<p>可以看到两种调用方法字面上的差异是有无关键字new。下面看看两种调用方式的具体区别。</p>
<p>首先我们定义一个函数Animal。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义函数Animal</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">animalName</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'function is called'</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.eat);</span><br><span class="line">   <span class="keyword">this</span>.name = animalName;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'function is going to return'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上文说的，所有的function变量都有prototype属性，所以我们可以这样给prototype属性添加方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给函数Animal的prototype属性添加eat方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'eating'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先来看普通调用的情况:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是A行</span></span><br><span class="line"><span class="keyword">var</span> dog = Animal(<span class="string">'dog'</span>);  <span class="comment">//调用函数Animal，未使用new  ******* A ******</span></span><br><span class="line">                          <span class="comment">//上面这行代码的意思可以理解为：调用Animal函数，并把返回值赋给变量dog;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog);         <span class="comment">//打印结果为undefined</span></span><br><span class="line"><span class="comment">/*******</span><br><span class="line">* 对于上面这行打印结果的解释:变量dog的值为undefined是因为函数Animal的定义的最后并没有写上return，既函数本身没有任何返回值，既undefined</span><br><span class="line">******/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">//打印结果为dog。对于这个打印的解释请往下看。</span></span><br></pre></td></tr></table></figure></p>
<p>让我们看看在上面A行调用过程中，到底发生了什么。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">animalName</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'function is called'</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//打印结果为Window &#123;external: Object, chrome: Object, document: document, dog: undefined, speechSynthesis: SpeechSynthesis…&#125;</span></span><br><span class="line">   <span class="comment">/******</span><br><span class="line">   *  对于以上面这行打印结果的解释： 这里打印的是对象window。window对象是由浏览器用类似下面的代码自动创建的</span><br><span class="line">   *  var window = new Window();</span><br><span class="line">   *</span><br><span class="line">   *  因为A行是直接在全局作用域调、既window对象上调用了Animal('dog')，所以this引用的是window对象。</span><br><span class="line">   *</span><br><span class="line">   *  既JavaScript内部执行了类似这样的代码:</span><br><span class="line">   *  this = window;</span><br><span class="line">   *</span><br><span class="line">   ******/</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.eat);   <span class="comment">//打印结果为undefined。这是由于this引用了window，而window本身并没有eat方法。</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.name = animalName;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">//打印结果为dog。因为上面一行将函数参数animalName的值，也就是'dog'赋给this.name，所以这里打印出'dog'。</span></span><br><span class="line">                            <span class="comment">//再次注意这里的this已经引用了对象window，所以给this添加name属性既给window添加了name属性。</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'function is going to return'</span>);</span><br><span class="line">   <span class="comment">// 函数体的最后并没有显性的写上return;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看看使用new关键字调用Animal时会发生什么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是B行</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal(<span class="string">'dog'</span>); <span class="comment">//在Animal的调用前使用了关键字new，则此时Animal函数成为了构造函数。  ********* B *********</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog);            <span class="comment">//打印结果为 Animal &#123;name: "dog"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name)     <span class="comment">//打印结果为undefined;</span></span><br></pre></td></tr></table></figure>
<p>B行在函数Animal的调用Animal()前加上了关键字new，像这样在函数调用前加上new，此时函数就被当作构造函数使用了。这里的”构造”过程如下:</p>
<p>1.在JavaScript内部，new会创建一个对象{}。你可以想象成JavaScript内部执行了这样一行代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newObject = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>2.这个对象的__proto__属性随即引用了Animal的prototype属性。你可以想像成JavaScript内部执行了这样的代码:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(newObject, Animal.prototype);  <span class="comment">//设置newObject的__proto__属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面一行也可以写成newObject.__proto__ = Animal.prototype。</span></span><br><span class="line"><span class="comment">// __proto__是JavaScript对象里特有的属性，它引用构造函数的prototype属性。</span></span><br><span class="line"><span class="comment">// 你可以这样访问__proto__属性，Object.getPrototypeOf(newObject)，或者newObject.__proto__;</span></span><br></pre></td></tr></table></figure></p>
<p>3.随即发生了类似这样的操作:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Animal.call(newObject, <span class="string">'dog'</span>); <span class="comment">//这里相当于使用了函数的call方法改变了函数内部this的指向。</span></span><br></pre></td></tr></table></figure>
<p>4.最后，这个由new创建的对象会被函数返回，既<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">'dog'</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  newObject.name = <span class="string">'dog'</span>;</span><br><span class="line">  <span class="keyword">return</span> newObject;        <span class="comment">//相当于JavaScript内部自动给我们的函数定义添加了一句return this;注意，只有当有new关键字出现时，才会自动添加这句。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的看一下B行调用Animal的过程中，发生了什么：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">animalName</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'function is called'</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//打印结果为 &gt; Animal &#123;&#125;</span></span><br><span class="line">   <span class="comment">/******</span><br><span class="line">   * 调用对象被new关键字设置为了newObject，所以这里打印的是&#123;&#125;, 前面的"Animal" 是告诉你这个&#123;&#125;的构造函数为Animal</span><br><span class="line">   * 而由于作用域中有 this.name = animalName这行代码，所以如果你点击该行打印结果前面的箭头展开这个对象，你会看到这个&#123;&#125;已经具备了name属性。关于作用域，这里就不展开说了。</span><br><span class="line">   ******/</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.eat);   <span class="comment">//打印结果为function()&#123;console.log('eating')&#125;</span></span><br><span class="line">   <span class="comment">/*****</span><br><span class="line">   * 上文中的构造过程第2步中已经说明newObject的__proto__属性引用了Animal.prototype属性。</span><br><span class="line">   * 这里的eat方法正是来自于__proto__属性。而JavaScript中规定，只要是__proto__上的属性，都可以省略__proto__，直接通过newObject.eat来访问。</span><br><span class="line">   ***/</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.name = animalName;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">//打印结果为dog。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'function is going to return'</span>);</span><br><span class="line">   <span class="comment">// 函数体的最后并没有显性的写上return;</span></span><br><span class="line">   <span class="comment">// 但是由于用new关键字调用了函数Animal，所以这里相当于执行了 return this;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="典型的继承写法"><a href="#典型的继承写法" class="headerlink" title="典型的继承写法"></a>典型的继承写法</h2><p>先总结一下上文出现的概念:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>JavaScript里的函数都有prototype属性。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>对象都有__proto__属性。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>对象的__proto__属性引用创建其的构造函数的prototype属性。</span><br></pre></td></tr></table></figure>
<p>如果理解了上面的这三条概念，那么就不难理解继承了。我们来看JavaScript里典型的继承写法:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">animalName</span>)</span>&#123;        <span class="comment">//定义函数Animal</span></span><br><span class="line">   <span class="keyword">this</span>.name = animalName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//给Animal的prototype属性添加eat方法</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'eating'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;&#125;                    <span class="comment">//定义函数Dog</span></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal(<span class="string">'dog'</span>);  <span class="comment">//将函数Dog的prototype属性引用为函数Animal"构造"的对象，这步是重点，继承在这里发生了。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype);         <span class="comment">//打印结果为 Animal &#123;name:'dog'&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype.name);    <span class="comment">//打印结果为'dog'</span></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype.eat());   <span class="comment">//打印结果为'eating'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype.hasOwnPropety(<span class="string">'name'</span>))          <span class="comment">// 打印 true</span></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype.hasOwnPropety(<span class="string">'eat'</span>))           <span class="comment">// 打印 false。上面虽然调用eat方法成功了，但是令人意外的是Dog.prototype本身并没有eat方法。</span></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype.__proto__.hasOwnPropety(<span class="string">'eat'</span>)) <span class="comment">// 打印 true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'I can eat'</span>);&#125;;       <span class="comment">//给Animal的原型添加eat方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Human.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="comment">//这行代码可以拆成两行理解，</span></span><br><span class="line"><span class="comment">//var animal = new Animal; 此时animal.__proto__引用自Animal.prototype，既animal.__proto__.hasOwnPropety('eat')返回true</span></span><br><span class="line"><span class="comment">//Human.prototype = animal; 此时Human.prototype.__proto__.hasOwnPropety('eat')返回true</span></span><br><span class="line"><span class="comment">//则有 Human.prototype.__proto__.eat(); 打印 I can eat</span></span><br><span class="line"><span class="comment">//而JS中可以省略__proto__直接用"."去访问__proto__上的属性，所以这时候可以像这样调用eat方法：</span></span><br><span class="line"><span class="comment">//Human.prototype.eat(); 打印 I can eat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以应该可以理解下面的代码了:</span></span><br><span class="line"><span class="comment">//var someone = new Human();</span></span><br><span class="line"><span class="comment">//上面的new构造过程包括了这样的操作: someone.__proto__ = Human.prototype;</span></span><br><span class="line"><span class="comment">//既someone.__proto__ = animal;</span></span><br><span class="line"><span class="comment">//则有:</span></span><br><span class="line"><span class="comment">//someone.__proto__.__proto__.eat(); 打印 I can eat。</span></span><br><span class="line"><span class="comment">//省略__proto__后</span></span><br><span class="line"><span class="comment">//someone.eat();  I can eat</span></span><br><span class="line"><span class="comment">//既someone对象继承了Animal上的eat方法。</span></span><br><span class="line"></span><br><span class="line">Human.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'I can speak'</span>);&#125;;    <span class="comment">//此时Human.prototype这个由Animal构造的对象拥有了speak方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Coder</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Coder.prototype = <span class="keyword">new</span> Human();</span><br><span class="line">Coder.prototype.coding = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'I can coding'</span>);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSer</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">JSer.prototype = <span class="keyword">new</span> Coder();</span><br><span class="line">JSer.prototype.codingInJS = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'I can conding in JS'</span>);&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> JSer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型链来了：</span></span><br><span class="line"><span class="built_in">console</span>.log(me)                                                              <span class="comment">//打印结果为JSer &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(me.__proto__);                                                   <span class="comment">//打印结果为Coder &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(me.__proto__.__proto__);                                         <span class="comment">//打印结果为Human &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(me.__proto__.__proto__.__proto__);                               <span class="comment">//打印结果为Animal &#123;&#125;, 拥有speak方法的Animal构造出的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(me.__proto__.__proto__.__proto__.__proto__);                     <span class="comment">//打印结果为Animal &#123;&#125;, 没有speak方法</span></span><br><span class="line"><span class="built_in">console</span>.log(me.__proto__.__proto__.__proto__.__proto__.__proto__);           <span class="comment">//打印结果为Object &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(me.__proto__.__proto__.__proto__.__proto__.__proto__.__proto__); <span class="comment">//打印结果为null，此时原型链到达尽头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下调用均省略了__proto__属性</span></span><br><span class="line"><span class="built_in">console</span>.log(me.eat());                                              <span class="comment">//打印I can eat 。eat继承自构造函数Animal</span></span><br><span class="line"><span class="built_in">console</span>.log(me.speak());                                            <span class="comment">//打印I can speak。speak方法继承自构造函数Human</span></span><br><span class="line"><span class="built_in">console</span>.log(me.coding());                                           <span class="comment">//打印I can coding。 coding方法继承自构造函数Coder</span></span><br><span class="line"><span class="built_in">console</span>.log(me.codingInJS());                                       <span class="comment">//打印I can coding in JS。 codingInJS方法继承自构造函数JSer</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>JavaScript通过设置构造函数的prototype对象，从而决定了通过new构造出来的对象的__proto__属性。</li>
<li>因为每个对象都具备__proto__属性，从而实现了一条原型链。</li>
<li>又因为JavaScript可以省略__proto__去调用__proto__属性上的方法，所以我们就可以轻松的访问整条原型链上的属性了。</li>
</ol>
<p><em>赵彪原创，请随意转载，但务必保留作者署名和原文链接</em></p>
<img src="/images/support.png">
</div><div class="article__tags"><a href="/tags/JS继承/" class="article__tags__item">JS继承</a><a href="/tags/JavaScript/" class="article__tags__item">JavaScript</a></div><div itemscope itemprop="author" itemtype="https://schema.org/Person" class="article__author"><img src="/images/avatar.png" alt="Zhao Biao" class="article__author__image"><a title="About Zhao Biao" rel="author" class="article__author__link">Zhao Biao</a><p class="article__author__desc"></p><div class="article__author__socials"><a href="/atom.xml" title="rss" target="_blank" class="article__author__socials__item"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="Zhao Biao"></div><div id="sharer" class="sharer"><div class="sharer-inner"><div class="sharer__right"><button id="sharer-facebook" class="sharer__item"><i class="fa fa-facebook-official"></i></button><button id="sharer-twitter" class="sharer__item"><i class="fa fa-twitter"></i></button><button id="sharer-pinterest" class="sharer__item"><i class="fa fa-pinterest"></i></button><button id="sharer-pocket" class="sharer__item"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2017-08-23T19:18:29.000Z"><meta itemprop="articleBody" content="..."><meta itemprop="url" content="coderunthings.com/2015/11/06/inheritance/"><meta itemprop="mainEntityOfPage" content="coderunthings.com/2015/11/06/inheritance/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="把生命浪费在美好的代码上"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="coderunthings.com/images/site-logo.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="coderunthings.com/images/javascript_logo/js.jpg"><meta itemprop="url" content="coderunthings.com/images/javascript_logo/js.jpg"><meta itemprop="width"><meta itemprop="height"></div></article><section class="related-posts"><h3>Related posts</h3><div class="related-posts__item__wrapper"><a href="/2016/04/26/scopeandclosure/" class="related-posts__item"><div style="background-image: url('/images/javascript_logo/js.jpg')" class="related-posts__item__background"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">作用域和闭包--读《你不知道的JavaScript》</span></a></div><div class="related-posts__item__wrapper"><a href="/2015/11/21/checkarray/" class="related-posts__item"><div style="background-image: url('/images/javascript_logo/js.jpg')" class="related-posts__item__background"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">How to Check If it is Array?</span></a></div><div class="related-posts__item__wrapper"><a href="/2015/11/23/requirebasic/" class="related-posts__item"><div style="background-image: url('/images/javascript_logo/js.jpg')" class="related-posts__item__background"></div><div class="related-posts__item__overlay"></div><span class="related-posts__item__title">快速上手require.js</span></a></div></section></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/2017/08/20/howhexoworks/">hexo是怎么工作的</a></li><li class="recent-posts__item"><a href="/2017/08/12/js-standard/">用standard来管理JavaScript代码规范</a></li><li class="recent-posts__item"><a href="/2016/04/26/scopeandclosure/">作用域和闭包--读《你不知道的JavaScript》</a></li><li class="recent-posts__item"><a href="/2015/12/09/frontendvim/">现在开始用vim开发Web前端吧</a></li><li class="recent-posts__item"><a href="/2015/11/23/requirebasic/">快速上手require.js</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Tag cloud</h3><div class="tag-cloud"><a href="/tags/GitHub/" style="font-size: 0.75rem;">GitHub</a> <a href="/tags/JS继承/" style="font-size: 0.75rem;">JS继承</a> <a href="/tags/JavaScript/" style="font-size: 1.5rem;">JavaScript</a> <a href="/tags/front-end-tool/" style="font-size: 0.75rem;">front-end tool</a> <a href="/tags/hexo/" style="font-size: 0.75rem;">hexo</a> <a href="/tags/requirejs/" style="font-size: 0.75rem;">requirejs</a> <a href="/tags/sass/" style="font-size: 0.75rem;">sass</a> <a href="/tags/vim/" style="font-size: 0.75rem;">vim</a> <a href="/tags/旧博客/" style="font-size: 0.75rem;">旧博客</a></div></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/sass/">sass</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/HowItWorks/">HowItWorks</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/HowItWorks/hexo/">hexo</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/requirejs/">requirejs</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/standard/">standard</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/GitHub/">GitHub</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/vim/">vim</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/旧博客/">旧博客</a><span class="category-list-count">1</span></li></ul></div></div></div><p class="copyright"><small>© 2017 Zhao Biao<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><img src="http://www.honghucanyin.com.cn/images/abfood2.png" alt="" style="display:none"><script src="/js/sharer.min.js"></script></body></html>